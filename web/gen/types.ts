// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: `${string}://{api_base_url}` | (string & {})
}

export type ChatRequest = {
  /**
   * User Input/Question content.
   */
  query: string
  /**
   * Allows the entry of various variable values defined by the App. Contains key/value pairs. Default {}.
   */
  inputs?: {
    [key: string]: unknown
  }
  /**
   * Mode of response return. `streaming` (recommended) uses SSE. `blocking` returns after completion (may be interrupted for long processes; not supported in Agent Assistant mode). Cloudflare timeout is 100s.
   */
  response_mode?: 'streaming' | 'blocking'
  /**
   * User identifier, unique within the application. **Note**: The Service API does not share conversations created by the WebApp. Conversations created through the API are isolated from those created in the WebApp interface.
   */
  user: string
  /**
   * Conversation ID to continue a conversation. Pass the previous message's conversation_id.
   */
  conversation_id?: string
  /**
   * File list (images) for Vision-capable models.
   */
  files?: Array<InputFileObject>
  /**
   * Auto-generate conversation title. Default `true`. If `false`, use conversation rename API with `auto_generate: true` for async title generation.
   */
  auto_generate_name?: boolean
}

export type InputFileObject = ({
  transfer_method?: 'remote_url'
  url: string
} | {
  transfer_method?: 'local_file'
  upload_file_id: string
}) & {
  /**
   * Supported type: `image`.
   */
  type: 'image'
  /**
   * Transfer method, `remote_url` for image URL / `local_file` for file upload
   */
  transfer_method: 'remote_url' | 'local_file'
  /**
   * Image URL (when the transfer method is `remote_url`)
   */
  url?: string
  /**
   * Uploaded file ID, which must be obtained by uploading through the File Upload API in advance (when the transfer method is `local_file`)
   */
  upload_file_id?: string
}

/**
 * Response object for blocking mode chat completion.
 */
export type ChatCompletionResponse = {
  /**
   * Event type, fixed as `message`.
   */
  event?: string
  /**
   * Task ID for request tracking and stop response API.
   */
  task_id?: string
  /**
   * Unique ID of this response/message event.
   */
  id?: string
  /**
   * Unique message ID.
   */
  message_id?: string
  /**
   * Conversation ID.
   */
  conversation_id?: string
  /**
   * App mode, fixed as `chat`.
   */
  mode?: string
  /**
   * Complete response content.
   */
  answer?: string
  metadata?: {
    usage?: Usage
    retriever_resources?: Array<RetrieverResource>
  }
  /**
   * Message creation timestamp (Unix epoch seconds).
   */
  created_at?: number
}

/**
 * Base schema for Server-Sent Event chunks in streaming mode.
 */
export type ChunkChatEvent = {
  /**
   * The type of event.
   */
  event: 'message' | 'agent_message' | 'tts_message' | 'tts_message_end' | 'agent_thought' | 'message_file' | 'message_end' | 'message_replace' | 'error' | 'ping'
}

export type StreamEventBase = {
  /**
   * Task ID.
   */
  task_id?: string
  /**
   * Unique message ID.
   */
  message_id?: string
  /**
   * Conversation ID.
   */
  conversation_id?: string
  /**
   * Creation timestamp.
   */
  created_at?: number
}

export type StreamEventChatMessage = Omit<ChunkChatEvent, 'event'> & StreamEventBase & {
  /**
   * LLM returned text chunk.
   */
  answer: string
  event: 'message'
}

export type StreamEventChatAgentMessage = Omit<ChunkChatEvent, 'event'> & StreamEventBase & {
  /**
   * LLM returned text chunk (Agent mode).
   */
  answer: string
  event: 'agent_message'
}

export type StreamEventChatTtsMessage = Omit<ChunkChatEvent, 'event'> & StreamEventBase & {
  /**
   * Base64 encoded audio chunk.
   */
  audio: string
  event: 'tts_message'
}

export type StreamEventChatTtsMessageEnd = Omit<ChunkChatEvent, 'event'> & StreamEventBase & {
  /**
   * Empty string for end event.
   */
  audio: string
  event: 'tts_message_end'
}

export type StreamEventChatAgentThought = Omit<ChunkChatEvent, 'event'> & StreamEventBase & {
  /**
   * Agent thought ID.
   */
  id: string
  /**
   * Position of this thought in the sequence for the message.
   */
  position: number
  /**
   * What LLM is thinking.
   */
  thought?: string
  /**
   * Response from tool calls.
   */
  observation?: string
  /**
   * List of tools called, split by ';'.
   */
  tool?: string
  /**
   * Input of tools in JSON format. Example: {"dalle3": {"prompt": "a cute cat"}}.
   */
  tool_input?: string
  /**
   * File IDs of files related to this thought (e.g., generated by a tool).
   */
  message_files?: Array<string>
  event: 'agent_thought'
}

export type StreamEventChatMessageFile = Omit<ChunkChatEvent, 'event'> & {
  /**
   * File unique ID.
   */
  id: string
  /**
   * File type, currently only 'image'.
   */
  type: 'image'
  /**
   * Who this file belongs to, always 'assistant' here.
   */
  belongs_to: 'assistant'
  /**
   * Remote URL of the file.
   */
  url: string
  /**
   * Conversation ID.
   */
  conversation_id: string
  event: 'message_file'
}

export type StreamEventChatMessageEnd = Omit<ChunkChatEvent, 'event'> & StreamEventBase & {
  metadata: {
    usage?: Usage
    retriever_resources?: Array<RetrieverResource>
  }
  event: 'message_end'
}

export type StreamEventChatMessageReplace = Omit<ChunkChatEvent, 'event'> & StreamEventBase & {
  /**
   * Replacement content.
   */
  answer: string
  event: 'message_replace'
}

export type StreamEventChatError = Omit<ChunkChatEvent, 'event'> & StreamEventBase & {
  /**
   * HTTP status code.
   */
  status: number
  /**
   * Error code.
   */
  code: string
  /**
   * Error message.
   */
  message: string
  event: 'error'
}

export type StreamEventChatPing = Omit<ChunkChatEvent, 'event'> & {
  event: 'ping'
  [key: string]: unknown | 'ping'
}

/**
 * Model usage information.
 */
export type Usage = {
  prompt_tokens?: number
  prompt_unit_price?: string
  prompt_price_unit?: string
  prompt_price?: string
  completion_tokens?: number
  completion_unit_price?: string
  completion_price_unit?: string
  completion_price?: string
  total_tokens?: number
  total_price?: string
  currency?: string
  latency?: number
}

/**
 * Citation and Attribution information for a resource.
 */
export type RetrieverResource = {
  /**
   * Position of the resource in the list.
   */
  position?: number
  /**
   * ID of the dataset.
   */
  dataset_id?: string
  /**
   * Name of the dataset.
   */
  dataset_name?: string
  /**
   * ID of the document.
   */
  document_id?: string
  /**
   * Name of the document.
   */
  document_name?: string
  /**
   * ID of the specific segment within the document.
   */
  segment_id?: string
  /**
   * Relevance score of the resource.
   */
  score?: number
  /**
   * Content snippet from the resource.
   */
  content?: string
}

export type FileUploadResponse = {
  id?: string
  name?: string
  size?: number
  extension?: string
  mime_type?: string
  created_by?: string
  created_at?: number
}

export type MessageFeedbackRequest = {
  rating?: 'like' | 'dislike' | null
  user: string
  content?: string
}

export type AppFeedbacksResponse = {
  data?: Array<FeedbackItem>
}

export type FeedbackItem = {
  id?: string
  app_id?: string
  conversation_id?: string
  message_id?: string
  rating?: 'like' | 'dislike' | null
  content?: string
  from_source?: string
  from_end_user_id?: string
  from_account_id?: string | null
  created_at?: string
  updated_at?: string
}

export type SuggestedQuestionsResponse = {
  result?: string
  data?: Array<string>
}

export type ConversationHistoryResponse = {
  limit?: number
  has_more?: boolean
  data?: Array<ConversationMessageItem>
}

export type ConversationMessageItem = {
  id?: string
  conversation_id?: string
  inputs?: {
    [key: string]: unknown
  }
  query?: string
  answer?: string
  message_files?: Array<MessageFileItem>
  feedback?: {
    rating?: 'like' | 'dislike'
  } | null
  retriever_resources?: Array<RetrieverResource>
  agent_thoughts?: Array<AgentThoughtItem>
  created_at?: number
}

export type MessageFileItem = {
  id?: string
  /**
   * File type, e.g., 'image'.
   */
  type?: string
  /**
   * Preview image URL.
   */
  url?: string
  /**
   * Who this file belongs to.
   */
  belongs_to?: 'user' | 'assistant'
}

export type AgentThoughtItem = {
  /**
   * Agent thought ID.
   */
  id?: string
  /**
   * Unique message ID this thought belongs to.
   */
  message_id?: string
  /**
   * Position of this thought.
   */
  position?: number
  /**
   * What LLM is thinking.
   */
  thought?: string
  /**
   * Tools called, split by ';'.
   */
  tool?: string
  /**
   * Input of tools in JSON format.
   */
  tool_input?: string
  /**
   * Response from tool calls.
   */
  observation?: string
  /**
   * File IDs related to this thought (from example, Markdown text says 'message_files').
   */
  files?: Array<string>
  /**
   * Creation timestamp.
   */
  created_at?: number
}

export type ConversationsListResponse = {
  limit?: number
  has_more?: boolean
  data?: Array<ConversationListItem>
}

export type ConversationListItem = {
  id?: string
  name?: string
  inputs?: {
    [key: string]: unknown
  }
  status?: string
  introduction?: string
  created_at?: number
  updated_at?: number
}

export type ConversationRenameRequest = {
  /**
   * (Optional) The name of the conversation. Omit if auto_generate is true.
   */
  name?: string
  /**
   * (Optional) Automatically generate the title. Default false.
   */
  auto_generate?: boolean
  /**
   * The user identifier.
   */
  user: string
}

export type ConversationRenameResponse = ConversationListItem

export type ConversationVariablesResponse = {
  /**
   * Number of items per page.
   */
  limit?: number
  /**
   * Whether there is a next page.
   */
  has_more?: boolean
  data?: Array<ConversationVariableItem>
}

export type ConversationVariableItem = {
  /**
   * Variable ID.
   */
  id?: string
  /**
   * Variable name.
   */
  name?: string
  /**
   * Variable type (string, number, object, json, etc.).
   */
  value_type?: string
  /**
   * Variable value (can be a JSON string for complex types).
   */
  value?: string
  /**
   * Variable description.
   */
  description?: string
  /**
   * Creation timestamp.
   */
  created_at?: number
  /**
   * Last update timestamp.
   */
  updated_at?: number
}

export type AudioToTextRequest = {
  /**
   * Audio file. Supported: mp3, mp4, mpeg, mpga, m4a, wav, webm. Limit: 15MB.
   */
  file: Blob | File
  /**
   * User identifier.
   */
  user: string
}

export type AudioToTextResponse = {
  /**
   * Output text from speech recognition.
   */
  text?: string
}

/**
 * Requires `user`. Provide either `message_id` or `text`.
 */
export type TextToAudioFormRequest = {
  /**
   * Message ID (priority if both text and message_id provided).
   */
  message_id?: string
  /**
   * Speech content.
   */
  text?: string
  /**
   * User identifier.
   */
  user: string
}

export type AppInfoResponse = {
  name?: string
  description?: string
  tags?: Array<string>
}

export type ChatAppParametersResponse = {
  opening_statement?: string
  suggested_questions?: Array<string>
  suggested_questions_after_answer?: {
    enabled?: boolean
  }
  speech_to_text?: {
    enabled?: boolean
  }
  text_to_speech?: {
    enabled?: boolean
    voice?: string
    language?: string
    autoPlay?: 'enabled' | 'disabled'
  }
  retriever_resource?: {
    enabled?: boolean
  }
  annotation_reply?: {
    enabled?: boolean
  }
  user_input_form?: Array<UserInputFormItem>
  file_upload?: {
    image?: {
      enabled?: boolean
      number_limits?: number
      detail?: string
      transfer_methods?: Array<'remote_url' | 'local_file'>
    }
  }
  system_parameters?: {
    file_size_limit?: number
    image_file_size_limit?: number
    audio_file_size_limit?: number
    video_file_size_limit?: number
  }
}

export type UserInputFormItem = TextInputControlWrapper | ParagraphControlWrapper | SelectControlWrapper

export type TextInputControlWrapper = {
  'text-input': TextInputControl
}

export type ParagraphControlWrapper = {
  paragraph: ParagraphControl
}

export type SelectControlWrapper = {
  select: SelectControl
}

export type TextInputControl = {
  label: string
  variable: string
  required: boolean
  default?: string
}

export type ParagraphControl = {
  label: string
  variable: string
  required: boolean
  default?: string
}

export type SelectControl = {
  label: string
  variable: string
  required: boolean
  default?: string
  options: Array<string>
}

export type AppMetaResponse = {
  /**
   * Tool icons. Keys are tool names.
   */
  tool_icons?: {
    [key: string]: string | ToolIconDetail
  }
}

export type ToolIconDetail = {
  /**
   * Background color in hex format.
   */
  background?: string
  /**
   * Emoji content.
   */
  content?: string
}

export type WebAppSettingsResponse = {
  title?: string
  chat_color_theme?: string
  chat_color_theme_inverted?: boolean
  icon_type?: 'emoji' | 'image'
  icon?: string
  icon_background?: string
  icon_url?: string | null
  description?: string
  copyright?: string
  privacy_policy?: string
  custom_disclaimer?: string
  default_language?: string
  show_workflow_steps?: boolean
  use_icon_as_answer_icon?: boolean
}

export type AnnotationListResponse = {
  data?: Array<AnnotationItem>
  has_more?: boolean
  limit?: number
  total?: number
  page?: number
}

export type AnnotationItem = {
  id?: string
  question?: string
  answer?: string
  hit_count?: number
  created_at?: number
}

export type CreateAnnotationRequest = {
  question: string
  answer: string
}

export type UpdateAnnotationRequest = {
  question: string
  answer: string
}

export type InitialAnnotationReplySettingsRequest = {
  /**
   * Specified embedding model provider name (Optional).
   */
  embedding_provider_name?: string
  /**
   * Specified embedding model name (Optional).
   */
  embedding_model_name?: string
  /**
   * Similarity threshold for matching annotated replies.
   */
  score_threshold: number
}

export type InitialAnnotationReplySettingsResponse = {
  job_id?: string
  job_status?: string
}

export type InitialAnnotationReplySettingsStatusResponse = {
  job_id?: string
  job_status?: string
  error_msg?: string | null
}

export type ErrorResponse = {
  status?: number
  code?: string
  message?: string
}

export type SendChatMessageData = {
  /**
   * Request body to send a chat message.
   */
  body: ChatRequest
  path?: never
  query?: never
  url: '/chat-messages'
}

export type SendChatMessageErrors = {
  /**
   * Bad Request. Possible error codes:
   * - `invalid_param`: Abnormal parameter input.
   * - `app_unavailable`: App configuration unavailable.
   * - `provider_not_initialize`: No available model credential configuration.
   * - `provider_quota_exceeded`: Model invocation quota insufficient.
   * - `model_currently_not_support`: Current model unavailable.
   * - `completion_request_error`: Text generation failed.
   */
  400: ErrorResponse
  /**
   * Conversation does not exist.
   */
  404: ErrorResponse
  /**
   * Internal server error.
   */
  500: ErrorResponse
}

export type SendChatMessageError = SendChatMessageErrors[keyof SendChatMessageErrors]

export type SendChatMessageResponses = {
  /**
   * Successful response. The content type and structure depend on the `response_mode` parameter in the request.
   * - If `response_mode` is `blocking`, returns `application/json` with a `ChatCompletionResponse` object.
   * - If `response_mode` is `streaming`, returns `text/event-stream` with a stream of `ChunkChatEvent` objects.
   */
  200: ChatCompletionResponse
}

export type SendChatMessageResponse = SendChatMessageResponses[keyof SendChatMessageResponses]

export type UploadChatFileData = {
  /**
   * File upload request. Requires multipart/form-data.
   */
  body: {
    /**
     * The file to be uploaded. Supported image types: png, jpg, jpeg, webp, gif.
     */
    file: Blob | File
    /**
     * User identifier, defined by the developer's rules, must be unique within the application. **Note**: The Service API does not share conversations created by the WebApp. Conversations created through the API are isolated from those created in the WebApp interface.
     */
    user: string
  }
  path?: never
  query?: never
  url: '/files/upload'
}

export type UploadChatFileErrors = {
  /**
   * Bad Request for file operations. Possible error codes:
   * - `no_file_uploaded`: A file must be provided.
   * - `too_many_files`: Currently only one file is accepted.
   * - `unsupported_preview`: The file does not support preview.
   * - `unsupported_estimate`: The file does not support estimation.
   */
  400: ErrorResponse
  /**
   * `file_too_large`: The file is too large.
   */
  413: ErrorResponse
  /**
   * `unsupported_file_type`: Unsupported extension. (Note: The description for `/files/upload` lists image types, while this generic error mentions document files. This might indicate a context-specific message from the backend).
   */
  415: ErrorResponse
  /**
   * Internal server error.
   */
  500: ErrorResponse
  /**
   * Service Unavailable for S3 operations. Possible error codes:
   * - `s3_connection_failed`: Unable to connect to S3 service.
   * - `s3_permission_denied`: No permission to upload files to S3.
   * - `s3_file_too_large`: File exceeds S3 size limit.
   */
  503: ErrorResponse
}

export type UploadChatFileError = UploadChatFileErrors[keyof UploadChatFileErrors]

export type UploadChatFileResponses = {
  /**
   * File uploaded successfully.
   */
  200: FileUploadResponse
}

export type UploadChatFileResponse = UploadChatFileResponses[keyof UploadChatFileResponses]

export type PreviewChatFileData = {
  body?: never
  path: {
    /**
     * The unique identifier of the file to preview, obtained from the File Upload API response.
     */
    file_id: string
  }
  query?: {
    /**
     * Whether to force download the file as an attachment. Default is `false` (preview in browser).
     */
    as_attachment?: boolean
  }
  url: '/files/{file_id}/preview'
}

export type PreviewChatFileErrors = {
  /**
   * Bad Request. Possible error codes:
   * - `invalid_param`: Abnormal parameter input.
   */
  400: ErrorResponse
  /**
   * Forbidden. Possible error codes:
   * - `file_access_denied`: File access denied or file does not belong to current application.
   */
  403: ErrorResponse
  /**
   * Not Found. Possible error codes:
   * - `file_not_found`: File not found or has been deleted.
   */
  404: ErrorResponse
  /**
   * Internal server error.
   */
  500: ErrorResponse
}

export type PreviewChatFileError = PreviewChatFileErrors[keyof PreviewChatFileErrors]

export type PreviewChatFileResponses = {
  /**
   * File content returned successfully. Headers set based on file type and request parameters.
   */
  200: Blob | File
}

export type PreviewChatFileResponse = PreviewChatFileResponses[keyof PreviewChatFileResponses]

export type StopChatMessageGenerationData = {
  body: {
    /**
     * User identifier, must be consistent with the user passed in the send message interface. **Note**: The Service API does not share conversations created by the WebApp. Conversations created through the API are isolated from those created in the WebApp interface.
     */
    user: string
  }
  path: {
    /**
     * Task ID, can be obtained from the streaming chunk return of a `/chat-messages` request.
     */
    task_id: string
  }
  query?: never
  url: '/chat-messages/{task_id}/stop'
}

export type StopChatMessageGenerationResponses = {
  /**
   * Operation successful.
   */
  200: {
    result?: string
  }
}

export type StopChatMessageGenerationResponse = StopChatMessageGenerationResponses[keyof StopChatMessageGenerationResponses]

export type PostChatMessageFeedbackData = {
  body: MessageFeedbackRequest
  path: {
    /**
     * Message ID for which feedback is being provided.
     */
    message_id: string
  }
  query?: never
  url: '/messages/{message_id}/feedbacks'
}

export type PostChatMessageFeedbackResponses = {
  /**
   * Operation successful.
   */
  200: {
    result?: string
  }
}

export type PostChatMessageFeedbackResponse = PostChatMessageFeedbackResponses[keyof PostChatMessageFeedbackResponses]

export type GetChatAppFeedbacksData = {
  body?: never
  path?: never
  query?: {
    /**
     * (optional) Pagination page number. Default: 1
     */
    page?: number
    /**
     * (optional) Records per page. Default: 20
     */
    limit?: number
  }
  url: '/app/feedbacks'
}

export type GetChatAppFeedbacksResponses = {
  /**
   * A list of application feedbacks.
   */
  200: AppFeedbacksResponse
}

export type GetChatAppFeedbacksResponse = GetChatAppFeedbacksResponses[keyof GetChatAppFeedbacksResponses]

export type GetSuggestedQuestionsData = {
  body?: never
  path: {
    /**
     * Message ID.
     */
    message_id: string
  }
  query: {
    /**
     * User identifier. **Note**: The Service API does not share conversations created by the WebApp. Conversations created through the API are isolated from those created in the WebApp interface.
     */
    user: string
  }
  url: '/messages/{message_id}/suggested'
}

export type GetSuggestedQuestionsResponses = {
  /**
   * Successfully retrieved suggested questions.
   */
  200: SuggestedQuestionsResponse
}

export type GetSuggestedQuestionsResponse = GetSuggestedQuestionsResponses[keyof GetSuggestedQuestionsResponses]

export type GetConversationHistoryData = {
  body?: never
  path?: never
  query: {
    /**
     * Conversation ID.
     */
    conversation_id: string
    /**
     * User identifier. **Note**: The Service API does not share conversations created by the WebApp. Conversations created through the API are isolated from those created in the WebApp interface.
     */
    user: string
    /**
     * The ID of the first chat record on the current page, default is null (for fetching the latest). For subsequent pages, use the ID of the first message from the current list to get older messages.
     */
    first_id?: string
    /**
     * How many chat history messages to return in one request, default is 20.
     */
    limit?: number
  }
  url: '/messages'
}

export type GetConversationHistoryResponses = {
  /**
   * Successfully retrieved conversation history.
   */
  200: ConversationHistoryResponse
}

export type GetConversationHistoryResponse = GetConversationHistoryResponses[keyof GetConversationHistoryResponses]

export type GetConversationsListData = {
  body?: never
  path?: never
  query: {
    /**
     * User identifier. **Note**: The Service API does not share conversations created by the WebApp. Conversations created through the API are isolated from those created in the WebApp interface.
     */
    user: string
    /**
     * (Optional) The ID of the last record on the current page (for pagination).
     */
    last_id?: string
    /**
     * (Optional) How many records to return. Default 20, Min 1, Max 100.
     */
    limit?: number
    /**
     * Sorting Field. Default: -updated_at. '-' prefix for descending.
     */
    sort_by?: 'created_at' | '-created_at' | 'updated_at' | '-updated_at'
  }
  url: '/conversations'
}

export type GetConversationsListResponses = {
  /**
   * Successfully retrieved conversations list.
   */
  200: ConversationsListResponse
}

export type GetConversationsListResponse = GetConversationsListResponses[keyof GetConversationsListResponses]

export type DeleteConversationData = {
  body: {
    /**
     * The user identifier. **Note**: The Service API does not share conversations created by the WebApp. Conversations created through the API are isolated from those created in the WebApp interface.
     */
    user: string
  }
  path: {
    /**
     * Conversation ID.
     */
    conversation_id: string
  }
  query?: never
  url: '/conversations/{conversation_id}'
}

export type DeleteConversationResponses = {
  /**
   * Conversation deleted successfully. No Content.
   */
  204: void
}

export type DeleteConversationResponse = DeleteConversationResponses[keyof DeleteConversationResponses]

export type RenameConversationData = {
  body: ConversationRenameRequest
  path: {
    /**
     * Conversation ID.
     */
    conversation_id: string
  }
  query?: never
  url: '/conversations/{conversation_id}/name'
}

export type RenameConversationResponses = {
  /**
   * Conversation renamed successfully.
   */
  200: ConversationListItem
}

export type RenameConversationResponse = RenameConversationResponses[keyof RenameConversationResponses]

export type GetConversationVariablesData = {
  body?: never
  path: {
    /**
     * The ID of the conversation to retrieve variables from.
     */
    conversation_id: string
  }
  query: {
    /**
     * The user identifier.
     */
    user: string
    /**
     * (Optional) The ID of the last record on the current page (for pagination).
     */
    last_id?: string
    /**
     * (Optional) How many records to return. Default 20, Min 1, Max 100.
     */
    limit?: number
    /**
     * (Optional) Filter variables by a specific name.
     */
    variable_name?: string
  }
  url: '/conversations/{conversation_id}/variables'
}

export type GetConversationVariablesErrors = {
  /**
   * Conversation not found. Error code: `conversation_not_exists`
   */
  404: ErrorResponse
}

export type GetConversationVariablesError = GetConversationVariablesErrors[keyof GetConversationVariablesErrors]

export type GetConversationVariablesResponses = {
  /**
   * Successfully retrieved conversation variables.
   */
  200: ConversationVariablesResponse
}

export type GetConversationVariablesResponse = GetConversationVariablesResponses[keyof GetConversationVariablesResponses]

export type AudioToTextData = {
  body: AudioToTextRequest
  path?: never
  query?: never
  url: '/audio-to-text'
}

export type AudioToTextResponses = {
  /**
   * Successfully converted audio to text.
   */
  200: AudioToTextResponse
}

export type AudioToTextResponse2 = AudioToTextResponses[keyof AudioToTextResponses]

export type TextToAudioChatData = {
  body: TextToAudioFormRequest
  path?: never
  query?: never
  url: '/text-to-audio'
}

export type TextToAudioChatResponses = {
  /**
   * The generated audio file.
   */
  200: Blob | File
}

export type TextToAudioChatResponse = TextToAudioChatResponses[keyof TextToAudioChatResponses]

export type GetChatAppInfoData = {
  body?: never
  path?: never
  query?: never
  url: '/info'
}

export type GetChatAppInfoResponses = {
  /**
   * Basic information of the application.
   */
  200: AppInfoResponse
}

export type GetChatAppInfoResponse = GetChatAppInfoResponses[keyof GetChatAppInfoResponses]

export type GetChatAppParametersData = {
  body?: never
  path?: never
  query: {
    /**
     * User identifier, defined by the developer's rules, must be unique within the application.
     */
    user: string
  }
  url: '/parameters'
}

export type GetChatAppParametersResponses = {
  /**
   * Application parameters information.
   */
  200: ChatAppParametersResponse
}

export type GetChatAppParametersResponse = GetChatAppParametersResponses[keyof GetChatAppParametersResponses]

export type GetChatAppMetaData = {
  body?: never
  path?: never
  query?: never
  url: '/meta'
}

export type GetChatAppMetaResponses = {
  /**
   * Successfully retrieved application meta information.
   */
  200: AppMetaResponse
}

export type GetChatAppMetaResponse = GetChatAppMetaResponses[keyof GetChatAppMetaResponses]

export type GetChatWebAppSettingsData = {
  body?: never
  path?: never
  query?: never
  url: '/site'
}

export type GetChatWebAppSettingsResponses = {
  /**
   * WebApp settings of the application.
   */
  200: WebAppSettingsResponse
}

export type GetChatWebAppSettingsResponse = GetChatWebAppSettingsResponses[keyof GetChatWebAppSettingsResponses]

export type GetAnnotationListData = {
  body?: never
  path?: never
  query?: {
    /**
     * Page number.
     */
    page?: number
    /**
     * Number of items returned, default 20, range 1-100.
     */
    limit?: number
  }
  url: '/apps/annotations'
}

export type GetAnnotationListResponses = {
  /**
   * Successfully retrieved annotation list.
   */
  200: AnnotationListResponse
}

export type GetAnnotationListResponse = GetAnnotationListResponses[keyof GetAnnotationListResponses]

export type CreateAnnotationData = {
  body: CreateAnnotationRequest
  path?: never
  query?: never
  url: '/apps/annotations'
}

export type CreateAnnotationResponses = {
  /**
   * Annotation created successfully.
   */
  200: AnnotationItem
}

export type CreateAnnotationResponse = CreateAnnotationResponses[keyof CreateAnnotationResponses]

export type DeleteAnnotationData = {
  body?: never
  path: {
    /**
     * Annotation ID.
     */
    annotation_id: string
  }
  query?: never
  url: '/apps/annotations/{annotation_id}'
}

export type DeleteAnnotationResponses = {
  /**
   * Annotation deleted successfully. No Content.
   */
  204: void
}

export type DeleteAnnotationResponse = DeleteAnnotationResponses[keyof DeleteAnnotationResponses]

export type UpdateAnnotationData = {
  body: UpdateAnnotationRequest
  path: {
    /**
     * Annotation ID.
     */
    annotation_id: string
  }
  query?: never
  url: '/apps/annotations/{annotation_id}'
}

export type UpdateAnnotationResponses = {
  /**
   * Annotation updated successfully.
   */
  200: AnnotationItem
}

export type UpdateAnnotationResponse = UpdateAnnotationResponses[keyof UpdateAnnotationResponses]

export type InitialAnnotationReplySettingsData = {
  body: InitialAnnotationReplySettingsRequest
  path: {
    /**
     * Action, can only be 'enable' or 'disable'.
     */
    action: 'enable' | 'disable'
  }
  query?: never
  url: '/apps/annotation-reply/{action}'
}

export type InitialAnnotationReplySettingsResponses = {
  /**
   * Annotation reply settings task initiated.
   */
  200: InitialAnnotationReplySettingsResponse
}

export type InitialAnnotationReplySettingsResponse2 = InitialAnnotationReplySettingsResponses[keyof InitialAnnotationReplySettingsResponses]

export type GetInitialAnnotationReplySettingsStatusData = {
  body?: never
  path: {
    /**
     * Action, must be the same as in the initial settings call ('enable' or 'disable').
     */
    action: 'enable' | 'disable'
    /**
     * Job ID obtained from the initial settings call.
     */
    job_id: string
  }
  query?: never
  url: '/apps/annotation-reply/{action}/status/{job_id}'
}

export type GetInitialAnnotationReplySettingsStatusResponses = {
  /**
   * Successfully retrieved task status.
   */
  200: InitialAnnotationReplySettingsStatusResponse
}

export type GetInitialAnnotationReplySettingsStatusResponse = GetInitialAnnotationReplySettingsStatusResponses[keyof GetInitialAnnotationReplySettingsStatusResponses]
