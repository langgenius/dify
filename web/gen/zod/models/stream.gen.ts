// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod'

import { zChunkChatEvent } from './chunk.gen'
import { zRetrieverResource } from './retriever.gen'
import { zUsage } from './usage.gen'

export const zStreamEventBase = z.object({
  task_id: z.string().uuid().describe('Task ID.').optional(),
  message_id: z.string().uuid().describe('Unique message ID.').optional(),
  conversation_id: z.string().uuid().describe('Conversation ID.').optional(),
  created_at: z.coerce.bigint().min(BigInt('-9223372036854775808'), { message: 'Invalid value: Expected int64 to be >= -9223372036854775808' }).max(BigInt('9223372036854775807'), { message: 'Invalid value: Expected int64 to be <= 9223372036854775807' }).describe('Creation timestamp.').optional(),
})

export type StreamEventBaseZodType = z.infer<typeof zStreamEventBase>

export const zStreamEventChatMessage = zChunkChatEvent.and(zStreamEventBase).and(z.object({
  answer: z.string().describe('LLM returned text chunk.'),
  event: z.literal('message'),
}))

export type StreamEventChatMessageZodType = z.infer<typeof zStreamEventChatMessage>

export const zStreamEventChatAgentMessage = zChunkChatEvent.and(zStreamEventBase).and(z.object({
  answer: z.string().describe('LLM returned text chunk (Agent mode).'),
  event: z.literal('agent_message'),
}))

export type StreamEventChatAgentMessageZodType = z.infer<typeof zStreamEventChatAgentMessage>

export const zStreamEventChatTtsMessage = zChunkChatEvent.and(zStreamEventBase).and(z.object({
  audio: z.string().describe('Base64 encoded audio chunk.'),
  event: z.literal('tts_message'),
}).describe('TTS audio stream event (base64 encoded Mp3). Available if auto-play enabled.'))

export type StreamEventChatTtsMessageZodType = z.infer<typeof zStreamEventChatTtsMessage>

export const zStreamEventChatTtsMessageEnd = zChunkChatEvent.and(zStreamEventBase).and(z.object({
  audio: z.string().describe('Empty string for end event.'),
  event: z.literal('tts_message_end'),
}).describe('TTS audio stream end event.'))

export type StreamEventChatTtsMessageEndZodType = z.infer<typeof zStreamEventChatTtsMessageEnd>

export const zStreamEventChatAgentThought = zChunkChatEvent.and(zStreamEventBase).and(z.object({
  id: z.string().uuid().describe('Agent thought ID.'),
  position: z.number().int().describe('Position of this thought in the sequence for the message.'),
  thought: z.string().describe('What LLM is thinking.').optional(),
  observation: z.string().describe('Response from tool calls.').optional(),
  tool: z.string().describe('List of tools called, split by \';\'.').optional(),
  tool_input: z.string().describe('Input of tools in JSON format. Example: {"dalle3": {"prompt": "a cute cat"}}.').optional(),
  message_files: z.array(z.string().uuid()).describe('File IDs of files related to this thought (e.g., generated by a tool).').optional(),
  event: z.literal('agent_thought'),
}).describe('Agent thought, LLM thinking, tool call details (Agent mode).'))

export type StreamEventChatAgentThoughtZodType = z.infer<typeof zStreamEventChatAgentThought>

export const zStreamEventChatMessageFile = zChunkChatEvent.and(z.object({
  id: z.string().uuid().describe('File unique ID.'),
  type: z.enum(['image']).describe('File type, currently only \'image\'.'),
  belongs_to: z.enum(['assistant']).describe('Who this file belongs to, always \'assistant\' here.'),
  url: z.string().describe('Remote URL of the file.'),
  conversation_id: z.string().uuid().describe('Conversation ID.'),
  event: z.literal('message_file'),
}).describe('Message file event, a new file created by a tool.'))

export type StreamEventChatMessageFileZodType = z.infer<typeof zStreamEventChatMessageFile>

export const zStreamEventChatMessageReplace = zChunkChatEvent.and(zStreamEventBase).and(z.object({
  answer: z.string().describe('Replacement content.'),
  event: z.literal('message_replace'),
}).describe('Message content replacement event (e.g., due to content moderation).'))

export type StreamEventChatMessageReplaceZodType = z.infer<typeof zStreamEventChatMessageReplace>

export const zStreamEventChatError = zChunkChatEvent.and(zStreamEventBase).and(z.object({
  status: z.number().int().describe('HTTP status code.'),
  code: z.string().describe('Error code.'),
  message: z.string().describe('Error message.'),
  event: z.literal('error'),
}).describe('Error event during streaming.'))

export type StreamEventChatErrorZodType = z.infer<typeof zStreamEventChatError>

export const zStreamEventChatPing = zChunkChatEvent.and(z.object({
  event: z.literal('ping'),
}).describe('Ping event to keep connection alive.'))

export type StreamEventChatPingZodType = z.infer<typeof zStreamEventChatPing>

export const zStreamEventChatMessageEnd = zChunkChatEvent.and(zStreamEventBase).and(z.object({
  metadata: z.object({
    usage: zUsage.optional(),
    retriever_resources: z.array(zRetrieverResource).optional(),
  }),
  event: z.literal('message_end'),
}).describe('Message end event, streaming has ended.'))

export type StreamEventChatMessageEndZodType = z.infer<typeof zStreamEventChatMessageEnd>
